import os
import numpy as np
import wave
from pydub import AudioSegment
from scipy.signal import find_peaks
from pydub.playback import play
import soundfile as sf
import scipy.io.wavfile as wav

#Constantes
fs = 44100
def cargar_archivos_de_audio(directorio):
    archivos_de_audio = []

    # Verifica si el directorio existe
    if not os.path.exists(directorio):
        print(f"El directorio '{directorio}' no existe.")
        return archivos_de_audio

    # Itera sobre los archivos en el directorio
    for archivo in os.listdir(directorio):
        if archivo.endswith(".wav"):
            archivos_de_audio.append(os.path.join(directorio, archivo))

    return archivos_de_audio

# Directorio que contiene los archivos de audio .wav
# Utiliza una ruta relativa desde el directorio donde se encuentra este script
directorio_audio = "carpeta_de_audios"

# Obtiene el directorio actual del script
directorio_actual = os.path.dirname(os.path.abspath(__file__))

# Combina el directorio actual con el directorio de audio
directorio_completo = os.path.join(directorio_actual, directorio_audio)

# Carga los archivos de audio
archivos_audio = cargar_archivos_de_audio(directorio_completo)

# Imprime la lista de archivos
for i, archivo in enumerate(archivos_audio):
    print(f"{i}: {archivo}")

# Elije el índice del archivo que deseas cargar
indice_archivo = 0  # Cambia este valor al índice del archivo que deseas cargar

if 0 <= indice_archivo < len(archivos_audio):
    archivo_seleccionado = archivos_audio[indice_archivo]
    print(f"Cargando archivo: {archivo_seleccionado}")

    # Llama a la función con el archivo seleccionado
    # Luego puedes realizar operaciones con el archivo, por ejemplo, cargarlo y procesarlo
    # Cargar el archivo, procesarlo, etc.
else:
    print("El índice seleccionado está fuera de rango. Debe estar en el rango [0, {}].".format(len(archivos_audio) - 1))




def sintetizar_respuesta_al_impulso(T60, frecuencias_centrales, duracion, nombre_archivo="respuesta_impulso.wav"):
    fs = 44100  # Frecuencia de muestreo (puedes ajustarla según tus necesidades)
    num_muestras = int(fs * duracion)
    tiempo = np.linspace(0, duracion, num_muestras, endpoint=False)
    
    respuesta_impulso = np.zeros(num_muestras)
    
    for i in range(len(frecuencias_centrales)):
        fi = frecuencias_centrales[i]
        Ti60i = T60[i]
        tau_i = -np.log(10 ** -3) / Ti60i
        
        # Generar una señal de respuesta al impulso con decaimiento exponencial
        yi = np.exp(-tiempo / tau_i) * np.cos(2 * np.pi * fi * tiempo)
        
        respuesta_impulso += yi
    
    respuesta_impulso /= np.max(np.abs(respuesta_impulso))
    
    # Escalar la respuesta al impulso a un rango adecuado para exportarla como audio
    respuesta_impulso *= 32767.0  # Valor máximo para audio de 16 bits
    
    respuesta_impulso = respuesta_impulso.astype(np.int16)
    
    # Crear un archivo WAV con formato de 16 bits y PCM
    AudioSegment(
        respuesta_impulso.tobytes(),
        frame_rate=fs,
        sample_width=2,
        channels=1
    ).export(nombre_archivo, format="wav")

# Ejemplo de uso
T60 = [3.86, 2.86, 2.59, 2.61]
frecuencias_centrales = [125, 250, 500, 1000]
duracion = max(T60) + 5
nombre_archivo = "respuesta_impulso.wav"

#sintetizar_respuesta_al_impulso(T60, frecuencias_centrales, duracion, nombre_archivo)

# Reproducir la respuesta al impulso generada
#play(AudioSegment.from_wav(nombre_archivo))


sine_sweep = "sine_sweepDR.wav"
filtro_inv = "filtro_inversoDR.wav"

def obtencion_rta_al_impulso(sine_sweep, filtro_inv):

    y_t, fs = sf.read(sine_sweep)
    k_t, fs = sf.read(filtro_inv)

    # Calcular la Transformada de Fourier
    Y_jw = np.fft.fft(y_t)
    K_jw = np.fft.fft(k_t)
    H_jw = Y_jw * K_jw
    # Calcular la antitransformada de Fourier
    h_t = np.fft.ifft(H_jw).real
    h_t = h_t.astype('float32')
    sf.write("RI_recinto.wav", h_t, 44100)

    return h_t

# Llamar a la función
obtencion_rta_al_impulso(sine_sweep, filtro_inv)



def apply_iec61260_filters(audio_signal, sample_rate=44100):
    # Lista de frecuencias centrales según la norma IEC61260 para octavas y tercios de octava
    center_frequencies = [31.5, 63, 125, 250, 500, 1000, 2000, 4000, 8000]

    filtered_signals = []

    for center_frequency in center_frequencies:
        G = 1.0 / 2.0  # Octava - G = 1.0/2.0 / 1/3 de Octava - G=1.0/6.0
        factor = np.power(2, G)
        center_frequency_hz = center_frequency

        lower_cutoff_frequency_hz = center_frequency_hz / factor
        upper_cutoff_frequency_hz = center_frequency_hz * factor

        # Extraer coeficientes del filtro
        b, a = audio_signal.iirfilter(4, [2 * np.pi * lower_cutoff_frequency_hz, 2 * np.pi * upper_cutoff_frequency_hz],
                                rs=60, btype='band', analog=True,
                                ftype='butter')

        # Para aplicar el filtro de manera más óptima
        sos = audio_signal.iirfilter(4, [lower_cutoff_frequency_hz, upper_cutoff_frequency_hz],
                               rs=60, btype='band', analog=False,
                               ftype='butter', fs=sample_rate, output='sos')
        filtered_signal = audio_signal.sosfilt(sos, audio_signal)

        filtered_signals.append(filtered_signal)

    return filtered_signals

def convertir_a_escala_logaritmica(ri):
    """
    Convierte la respuesta al impulso (RI) a escala logarítmica.

    Parámetros:
    ri (numpy.ndarray): La respuesta al impulso a convertir.

    Retorna:
    numpy.ndarray: La señal resultante en escala logarítmica.
    """
    # Calcula el valor máximo de la RI
    max_ri = np.max(ri)

    # Aplica la conversión logarítmica
    signal_log = 20 * np.log10(ri / max_ri)

    return signal_log

