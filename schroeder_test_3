import numpy as np
import matplotlib.pyplot as plt
import soundfile as sf
epsilon=1e-10

def filtro_promedio_movil(signal, w_size=3):
    '''
    Calcula el promedio en un rango de valores de la señal original dado por w_size y los almacena en un array.
    
    Parametros
    ----------
    signal: Numpy array

    w_size: Tamaño de la ventana de muestreo.
           
    return: Numpy array con los valores de promedio móvil.

    Ejemplo
    -------
    import numpy as np
    import soundfile as sf
    
    signal, fs = sf.read('SineSweepLog.wav')
    filtro_promedio_movil(signal, w_size)
    
    '''
    signal_win = [] # Inicio una lista donde se van a almacenar los promedios móviles

    for i in range(len(signal)-(w_size-1)): # Ciclo for con rango hasta el ancho de la ventana
        w_i = signal[i : i + w_size]    # Ventana que itera en cada ciclo
        w_mean = np.mean(w_i)   # Calculo el promedio
        signal_win.append(w_mean)   # Agrego el promedio a la lista signal_win
    
    for i in range(w_size-1):   # Ciclo para que shape(signal)=shape(signal_win) agregando el último valor promediado
        signal_win.append(signal_win[-1])
       
    return(np.array(signal_win))   
w_size = 3
signal, fs = sf.read("señal_filtrada_1000.wav")
filt_signal = filtro_promedio_movil(signal, w_size)
filt_signal = sf.write("fpm_test_1000.wav", filt_signal, fs)

def schroeder(p_t, lim=4):
    """
    Calcula la integral de Schroeder.
    Parameters:
    signal (np.array): Array de la señal de audio.
    lim (int): Límite de la integral de Schroeder en segundos.
    Returns:
    numpy.ndarray: El array de la integral de Schroeder.
    """
    p_t= p_t[:int(lim * fs)]
    cut_lim = int(lim*fs)
    print("cut_lim=",cut_lim)
    
    E = np.sum(p_t[:]**2) - np.cumsum(p_t[:cut_lim]**2)
    E = 10 * np.log10(E / np.sum(p_t**2))
    

    return E

p_t, fs = sf.read("salida_filtrada_8000_fpm.wav")
lim = (int(len(p_t))/fs)
print("lim:",lim)
integral_schroeder = schroeder(p_t)
# Imprimir el resultado
print("longitud de la señal:", len(p_t))
print("longitud de schroeder", len(integral_schroeder))
print(integral_schroeder)



def convertir_audio_a_escala_logaritmica2(señal_audio):
    """
    Convierte un archivo de audio en escala logarítmica y devuelve el resultado como un array.

    Parámetros:
    señal_audio (np.array): Array de la señal de audio.

    Retorna:
    numpy.ndarray: El array de la señal en escala logarítmica.
    """
    # Normalizar los valores de audio entre -1 y 1
    audio_data = señal_audio.astype(np.float32) / np.max(np.abs(señal_audio))

    # Aplicar la conversión logarítmica
    audio_log = 20 * np.log10(np.abs(audio_data))

    return audio_log

def plot_dominio_temporal2(señal1, señal2, fs=44100, inicio=None, duracion=None, umbral_amplitud=None):
    """
    Muestra el dominio temporal de la señal con un umbral de amplitud.

    Parámetros
    ----------
    señal : np.array
        Array que representa la señal de audio.
    fs : int
        Frecuencia de muestreo en Hz de la señal.
    inicio : float, opcional
        Tiempo de inicio para la ventana en segundos.
    duracion : float, opcional
        Duración de la ventana en segundos.
    umbral_amplitud : float, opcional
        Umbral de amplitud para mostrar valores en el gráfico.

    Retorna
    -------
    None
    """
    # Calcula los valores de tiempo
    tiempo = np.arange(len(señal1)) / fs
    tiempo2 = np.arange(len(señal2)) / fs

    # Establece el índice de inicio y final
    if inicio is None:
        inicio = 0
    if duracion is None:
        duracion = tiempo[-1]

    # Encuentra los índices correspondientes al inicio y final de la ventana
    inicio_idx = int(inicio * fs)
    fin_idx = int((inicio + duracion) * fs)

    # Asegura que los índices estén dentro de los límites de la señal
    inicio_idx = max(0, inicio_idx)
    fin_idx = min(len(señal1), fin_idx)
    fin_idx2 = min(len(señal2), fin_idx)

    # Aplicar umbral de amplitud si se proporciona
    if umbral_amplitud is not None:
        señal1[señal1 < umbral_amplitud] = umbral_amplitud

    # Crea una nueva figura y plotea la señal en la ventana especificada
    plt.figure(figsize=(10, 4))
    plt.plot(tiempo[inicio_idx:fin_idx], señal1[inicio_idx:fin_idx])
    plt.plot(tiempo[inicio_idx:fin_idx2], señal2[inicio_idx:fin_idx2])
    plt.title('Dominio Temporal de la Señal')
    plt.xlabel('Tiempo (segundos)')
    plt.ylabel('Amplitud')
    plt.grid(True)
    plt.show()



# Normaliza la señal
normalized_audio = convertir_audio_a_escala_logaritmica2(p_t)
plot_dominio_temporal2(normalized_audio, integral_schroeder, fs)

def calcular_edt(schroeder, fs):
    """
    Calcula el tiempo de reverberación EDT desde una función de Schroeder suavizada.

    Parámetros:
    - schroeder: np.array, función de Schroeder suavizada.
    - fs: int, frecuencia de muestreo en Hz.

    Retorna:
    - edt: float, tiempo de reverberación EDT en segundos.
    """
    

    # Encuentra el tiempo en el que la integral cruza -10 dB
    umbral = -10  # Puedes ajustar este valor según las especificaciones de la ISO 3382
    indice_cruce = np.where(schroeder <= umbral)[0]
    print("Indice de cruce =", indice_cruce)
    if indice_cruce.size > 0:
        # Toma el primer índice de cruce
        indice_cruce = indice_cruce[0]

        # Convierte el índice a tiempo en segundos
        tiempo_cruce = indice_cruce / fs

        print("Tiempo de cruce =", tiempo_cruce)

        # El EDT es seis veces el tiempo en que la integral cruza -10 dB
        edt = 6 * tiempo_cruce
    
    else:
        # No se encontró ningún índice que cumpla con el umbral
        edt = 0  # O cualquier otro valor que desees asignar

    return edt
# Ejemplo de uso:
# Supongamos que tienes la función de Schroeder suavizada y la frecuencia de muestreo
schroeder = integral_schroeder  # Reemplaza con tu función de Schroeder
# Calculate the EDT
edt = calcular_edt(integral_schroeder, fs)
# Imprime el resultado
print("EDT:", edt, "segundos")

def calcular_t10(schroeder, fs):
    """
    Calcula el tiempo de reverberación T10 desde una función de Schroeder suavizada.

    Parámetros:
    - schroeder: np.array, función de Schroeder suavizada.
    - fs: int, frecuencia de muestreo en Hz.

    Retorna:
    - t10: float, tiempo de reverberación T10 en segundos.
    """
    # Encuentra el tiempo en el que la integral cruza -5 dB
    umbral_A= -5  # Puedes ajustar este valor según las especificaciones de la ISO 3382
    umbral_B = -15
    indice_cruce_5 = np.where(schroeder <= umbral_A)[0]
    indice_cruce_15 = np.where(schroeder <= umbral_B)[0]

    # Toma el primer índice de cruce
    indice_cruce_5 = indice_cruce_5[0]
    indice_cruce_15 = indice_cruce_15[0]
    
    # Convierte el índice a tiempo en segundos
    tiempo_cruce_5 = indice_cruce_5 / fs
    tiempo_cruce_15 = indice_cruce_15 / fs
    # La diferencia entre los dos cruces determina el tiempo de reverberación T10
    t10 = tiempo_cruce_15 - tiempo_cruce_5
    return t10

# Supongamos que tienes la función de Schroeder suavizada y la frecuencia de muestreo
schroeder = integral_schroeder  # Reemplaza con tu función de Schroeder
  # Reemplaza con tu frecuencia de muestreo
# Calculate the EDT
t10 = calcular_t10(integral_schroeder, fs)
# Imprime el resultado
print("T10:", t10, "segundos")

def calcular_t20(schroeder, fs):
    """
    Calcula el tiempo de reverberación T20 desde una función de Schroeder suavizada.

    Parámetros:
    - schroeder: np.array, función de Schroeder suavizada.
    - fs: int, frecuencia de muestreo en Hz.

    Retorna:
    - t10: float, tiempo de reverberación T10 en segundos.
    """
    # Encuentra el tiempo en el que la integral cruza -5 dB
    umbral_A= -5  # Puedes ajustar este valor según las especificaciones de la ISO 3382
    umbral_B = -25
    indice_cruce_5 = np.where(schroeder <= umbral_A)[0]
    indice_cruce_25 = np.where(schroeder <= umbral_B)[0]

    # Toma el primer índice de cruce
    indice_cruce_5 = indice_cruce_5[0]
    indice_cruce_25 = indice_cruce_25[0]
    
    # Convierte el índice a tiempo en segundos
    tiempo_cruce_5 = indice_cruce_5 / fs
    tiempo_cruce_25 = indice_cruce_25 / fs
    # La diferencia entre los dos cruces determina el tiempo de reverberación T10
    t20 = tiempo_cruce_25 - tiempo_cruce_5
    return t20

# Supongamos que tienes la función de Schroeder suavizada y la frecuencia de muestreo
schroeder = integral_schroeder  # Reemplaza con tu función de Schroeder
# Calculate the EDT
t20 = calcular_t20(integral_schroeder, fs)
# Imprime el resultado
print("T20:", t20, "segundos")

def calcular_t30(schroeder, fs):
    """
    Calcula el tiempo de reverberación T30 desde una función de Schroeder suavizada.

    Parámetros:
    - schroeder: np.array, función de Schroeder suavizada.
    - fs: int, frecuencia de muestreo en Hz.

    Retorna:
    - t30: float, tiempo de reverberación T30 en segundos.
    """
    # Encuentra el tiempo en el que la integral cruza -5 dB
    umbral_A= -5  # Puedes ajustar este valor según las especificaciones de la ISO 3382
    umbral_B = -35
    indice_cruce_5 = np.where(schroeder <= umbral_A)[0]
    indice_cruce_35 = np.where(schroeder <= umbral_B)[0]

    # Toma el primer índice de cruce
    indice_cruce_5 = indice_cruce_5[0]
    indice_cruce_35 = indice_cruce_35[0]
    
    # Convierte el índice a tiempo en segundos
    tiempo_cruce_5 = indice_cruce_5 / fs
    tiempo_cruce_35 = indice_cruce_35 / fs
    # La diferencia entre los dos cruces determina el tiempo de reverberación T10
    t30 = tiempo_cruce_35 - tiempo_cruce_5
    return t30

# Supongamos que tienes la función de Schroeder suavizada y la frecuencia de muestreo
schroeder = integral_schroeder  # Reemplaza con tu función de Schroeder
fs = 44100  # Reemplaza con tu frecuencia de muestreo
# Calcular T30
t30 = calcular_t30(integral_schroeder, fs)
# Imprime el resultado
print("T30:", t30, "segundos")



# D50
t_50 = int(0.05 * fs) 
integral_t_50 =  np.sum(np.power(integral_schroeder,2)[0:t_50])
print("Valor de la integral de cero hasta 50ms=",integral_t_50)
integral_total = np.sum(np.power(integral_schroeder,2))
print("Valor de la integral total=",integral_total)
D50 = integral_t_50 / integral_total
print("D50", D50,"%")

# Ejemplo de uso:
# Supongamos que tienes la función de Schroeder suavizada y la frecuencia de muestreo
schroeder =  integral_schroeder 


t_80 = int(0.08 * fs)
C80 = 10* (np.log10(np.sum(np.power(integral_schroeder,2)[0:t_80]) / np.sum(np.power(integral_schroeder,2)[t_80:])))
print("C80:", C80, "dB")