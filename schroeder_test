import numpy as np
import matplotlib.pyplot as plt
import soundfile as sf
import scipy.io.wavfile as wav
from pre_procesamiento import plot_dominio_temporal


def calculate_schroeder_integral(hA):
    """
    Calcula la integral de Schroeder para una respuesta al impulso dada.
    Parameters:
    - hA: np.array, respuesta al impulso suavizada.
    Returns:
    - E: np.array, valores de la integral de Schroeder.
    """
    # Crear el arreglo de tiempo
    tau = np.arange(0, len(hA))
    # Definir td y calcular la integral de Schroeder
    td = 100000 # Puedes ajustar este valor según tus necesidades
    E =  (np.sum(hA[:]**2) - (np.cumsum(hA[:]**2)))
    E = 10 *np.log10(E/np.sum(hA**2))
    return E
# Ejemplo de uso:
# Supongamos que tienes una respuesta al impulso suavizada hA

# Calcular la integral de Schroeder
hA, tasa_muestreo  = sf.read(r"C:\Users\duhal\Documents\A Ing. de Sonido\signal-systems-\TP Señales\Mi repo para TP SyS\respuesta_impulso.wav")
integral_schroeder = calculate_schroeder_integral(hA)
sf.write("Audio_Schroeder.wav", integral_schroeder,44100)
# Imprimir el resultado
print(integral_schroeder)
# Crear el arreglo de tiempo
tau = np.arange(0, len(hA))
# Graficar la señal original y la integral de Schroeder
plt.subplot(2, 1, 1)
plt.plot(tau, hA, label='Respuesta al Impulso Suavizada')
plt.title('Señal Original')
plt.xlabel('Tiempo')
plt.ylabel('Amplitud')
plt.legend()
plt.subplot(2, 1, 2)
plt.plot(tau, integral_schroeder, label='Integral de Schroeder')
plt.title('Integral de Schroeder')
plt.xlabel('Tiempo')
plt.ylabel('Amplitud (dB)')
plt.legend()
plt.tight_layout()
plt.show()

def convertir_audio_a_escala_logaritmica(señal_audio):
    """
    Convierte un archivo de audio en escala logarítmica y devuelve el resultado como un array.

    Parámetros:
    señal_audio (str): Ruta al archivo de audio de entrada (formato .wav).

    Retorna:
    numpy.ndarray: El array de la señal en escala logarítmica.
    """
    # Cargar el archivo de audio .wav
    tasa_muestreo, audio_data = wav.read(señal_audio)

    # Normalizar los valores de audio entre -1 y 1
    audio_data = audio_data.astype(np.float32) / 32767.0

    # Aplicar la conversión logarítmica
    audio_log = 20 * np.log10(np.abs(audio_data))

    return audio_log

def plot_dominio_temporal2(señal1 ,señal2 , fs=44100, inicio=None, duracion=None, umbral_amplitud=None):
    """
    Muestra el dominio temporal de la señal con un umbral de amplitud.

    Parámetros
    ----------
    señal : str o NumPy array
        Si es una cadena (str), se asume que es una ruta al archivo de audio WAV.
        Si es un NumPy array, se asume que es la señal directa.
    fs : int
        Frecuencia de muestreo en Hz de la señal.
    inicio : float, opcional
        Tiempo de inicio para la ventana en segundos.
    duracion : float, opcional
        Duración de la ventana en segundos.
    umbral_amplitud : float, opcional
        Umbral de amplitud para mostrar valores en el gráfico.

    Retorna
    -------
    None
    """
    if isinstance(señal1, str):  # Si es una cadena, se asume que es un archivo WAV
        tasa_muestreo, audio_data = wav.read(señal1)
        fs = tasa_muestreo
    else:  # Si es un NumPy array, se asume que es la señal directa
        audio_data = señal1
        
    if isinstance(señal2, str):  # Si es una cadena, se asume que es un archivo WAV
        tasa_muestreo2, audio_data2 = wav.read(señal2)
        fs = tasa_muestreo2
    else:  # Si es un NumPy array, se asume que es la señal directa
        audio_data2 = señal2

    # Calcula los valores de tiempo
    tiempo = np.arange(len(audio_data)) / fs
    tiempo2 = np.arange(len(audio_data2)) / fs

    # Establece el índice de inicio y final
    if inicio is None:
        inicio = 0
    if duracion is None:
        duracion = tiempo[-1]

    # Encuentra los índices correspondientes al inicio y final de la ventana
    inicio_idx = int(inicio * fs)
    fin_idx = int((inicio + duracion) * fs)

    # Asegura que los índices estén dentro de los límites de la señal
    inicio_idx = max(0, inicio_idx)
    fin_idx = min(len(audio_data), fin_idx)
    fin_idx2 = min(len(audio_data2), fin_idx)

    # Aplicar umbral de amplitud si se proporciona
    if umbral_amplitud is not None:
        audio_data[audio_data < umbral_amplitud] = umbral_amplitud

    # Crea una nueva figura y plotea la señal en la ventana especificada
    plt.figure(figsize=(10, 4))
    plt.plot(tiempo[inicio_idx:fin_idx], audio_data[inicio_idx:fin_idx])
    plt.plot(tiempo[inicio_idx:fin_idx2], audio_data2[inicio_idx:fin_idx2])
    plt.title('Dominio Temporal de la Señal')
    plt.xlabel('Tiempo (segundos)')
    plt.ylabel('Amplitud')
    plt.grid(True)
    plt.show()



señal_audio = "respuesta_impulso.wav"
audio_log = convertir_audio_a_escala_logaritmica(señal_audio)
plot_dominio_temporal2(audio_log, integral_schroeder ,fs= 44100)

