import numpy as np
import matplotlib.pyplot as plt
import soundfile as sf


def calculate_schroeder_integral(hA, lim=6):
    """
    Calcula la integral de Schroeder para una respuesta al impulso dada.
    Parameters:
    - hA: np.array, respuesta al impulso suavizada.
    Returns:
    - E: np.array, valores de la integral de Schroeder.
    """
    # Verificar que no haya valores nan o inf en la respuesta al impulso
    if np.isnan(hA).any() or np.isinf(hA).any():
        raise ValueError("La respuesta al impulso contiene valores no numéricos.")
    # Crear el arreglo de tiempo
    tau = np.arange(0, len(hA))
    cut_lim = lim*44100
    # Calcular la integral de Schroeder
    E = np.sum(hA[:]**2) - np.cumsum(hA[:cut_lim]**2)
    E = 10 * np.log10(E / np.sum(hA**2))
    #E = 10 * np.log10(np.cumsum(hA[::-1]**2)[::-1] / np.sum(hA**2))
    return E

# Calcular la integral de Schroeder
hA, tasa_muestreo = sf.read(r"C:\Users\duhal\Documents\A Ing. de Sonido\signal-systems-\TP Señales\Mi repo para TP SyS\señal_filtrada_1000.wav")
print ("longitud de hA",len(hA))
# lim = int((len(hA))/tasa_muestreo)
integral_schroeder = calculate_schroeder_integral(hA)
print("longitud schroeder", len(integral_schroeder))
sf.write("Audio_Schroeder.wav", integral_schroeder, 44100)
# Imprimir el resultado
print(integral_schroeder)

"""""
# Crear el arreglo de tiempo
tau = np.arange(0, len(hA))
# Graficar la señal original y la integral de Schroeder
plt.subplot(2, 1, 1)
plt.plot(tau, hA, label='Respuesta al Impulso Suavizada')
plt.title('Señal Original')
plt.xlabel('Tiempo')
plt.ylabel('Amplitud')
plt.legend()
plt.subplot(2, 1, 2)
plt.plot(tau, integral_schroeder, label='Integral de Schroeder')
plt.title('Integral de Schroeder')
plt.xlabel('Tiempo')
plt.ylabel('Amplitud (dB)')
plt.legend()
plt.tight_layout()
plt.show()
"""

def convertir_audio_a_escala_logaritmica(señal_audio):
    """
    Convierte un archivo de audio en escala logarítmica y devuelve el resultado como un array.

    Parámetros:
    señal_audio (np.array): Array de la señal de audio.

    Retorna:
    numpy.ndarray: El array de la señal en escala logarítmica.
    """
    # Normalizar los valores de audio entre -1 y 1
    audio_data = señal_audio.astype(np.float32) / np.max(np.abs(señal_audio))

    # Aplicar la conversión logarítmica
    audio_log = 20 * np.log10(np.abs(audio_data))

    return audio_log

def plot_dominio_temporal(señal, fs=44100, inicio=None, duracion=None, umbral_amplitud=None):
    """
    Muestra el dominio temporal de la señal con un umbral de amplitud.

    Parámetros
    ----------
    señal : str o NumPy array
        Si es una cadena (str), se asume que es una ruta al archivo de audio WAV.
        Si es un NumPy array, se asume que es la señal directa.
    fs : int
        Frecuencia de muestreo en Hz de la señal.
    inicio : float, opcional
        Tiempo de inicio para la ventana en segundos.
    duracion : float, opcional
        Duración de la ventana en segundos.
    umbral_amplitud : float, opcional
        Umbral de amplitud para mostrar valores en el gráfico.

    Retorna
    -------
    None
    """
    if isinstance(señal, str):  # Si es una cadena, se asume que es un archivo WAV
        tasa_muestreo, audio_data = wav.read(señal)
        fs = tasa_muestreo
    else:  # Si es un NumPy array, se asume que es la señal directa
        audio_data = señal

    # Calcula los valores de tiempo
    tiempo = np.arange(len(audio_data)) / fs

    # Establece el índice de inicio y final
    if inicio is None:
        inicio = 0
    if duracion is None:
        duracion = tiempo[-1]

    # Encuentra los índices correspondientes al inicio y final de la ventana
    inicio_idx = int(inicio * fs)
    fin_idx = int((inicio + duracion) * fs)

    # Asegura que los índices estén dentro de los límites de la señal
    inicio_idx = max(0, inicio_idx)
    fin_idx = min(len(audio_data), fin_idx)

    # Aplicar umbral de amplitud si se proporciona
    if umbral_amplitud is not None:
        audio_data[audio_data < umbral_amplitud] = umbral_amplitud

    # Crea una nueva figura y plotea la señal en la ventana especificada
    plt.figure(figsize=(10, 4))
    plt.plot(tiempo[inicio_idx:fin_idx], audio_data[inicio_idx:fin_idx])
    plt.title('Dominio Temporal de la Señal')
    plt.xlabel('Tiempo (segundos)')
    plt.ylabel('Amplitud')
    plt.grid(True)
    plt.show()

señal = sf.read("1st_baptist_nashville_balcony_mono_copy.wav")
plot = plot_dominio_temporal(señal)

def plot_dominio_temporal2(señal1, señal2, fs=44100, inicio=None, duracion=None, umbral_amplitud=None):
    """
    Muestra el dominio temporal de la señal con un umbral de amplitud.

    Parámetros
    ----------
    señal : np.array
        Array que representa la señal de audio.
    fs : int
        Frecuencia de muestreo en Hz de la señal.
    inicio : float, opcional
        Tiempo de inicio para la ventana en segundos.
    duracion : float, opcional
        Duración de la ventana en segundos.
    umbral_amplitud : float, opcional
        Umbral de amplitud para mostrar valores en el gráfico.

    Retorna
    -------
    None
    """
    # Calcula los valores de tiempo
    tiempo = np.arange(len(señal1)) / fs
    tiempo2 = np.arange(len(señal2)) / fs

    # Establece el índice de inicio y final
    if inicio is None:
        inicio = 0
    if duracion is None:
        duracion = tiempo[-1]

    # Encuentra los índices correspondientes al inicio y final de la ventana
    inicio_idx = int(inicio * fs)
    fin_idx = int((inicio + duracion) * fs)

    # Asegura que los índices estén dentro de los límites de la señal
    inicio_idx = max(0, inicio_idx)
    fin_idx = min(len(señal1), fin_idx)
    fin_idx2 = min(len(señal2), fin_idx)

    # Aplicar umbral de amplitud si se proporciona
    if umbral_amplitud is not None:
        señal1[señal1 < umbral_amplitud] = umbral_amplitud

    # Crea una nueva figura y plotea la señal en la ventana especificada
    plt.figure(figsize=(10, 4))
    plt.plot(tiempo[inicio_idx:fin_idx], señal1[inicio_idx:fin_idx])
    plt.plot(tiempo[inicio_idx:fin_idx2], señal2[inicio_idx:fin_idx2])
    plt.title('Dominio Temporal de la Señal')
    plt.xlabel('Tiempo (segundos)')
    plt.ylabel('Amplitud')
    plt.grid(True)
    plt.show()

# Normaliza la señal
normalized_audio = convertir_audio_a_escala_logaritmica(hA)
plot_dominio_temporal2(normalized_audio, integral_schroeder, fs=44100)



def calcular_edt(schroeder, fs):
    """
    Calcula el tiempo de reverberación EDT desde una función de Schroeder suavizada.

    Parámetros:
    - schroeder: np.array, función de Schroeder suavizada.
    - fs: int, frecuencia de muestreo en Hz.

    Retorna:
    - edt: float, tiempo de reverberación EDT en segundos.
    """
    

    # Encuentra el tiempo en el que la integral cruza -10 dB
    umbral = -10  # Puedes ajustar este valor según las especificaciones de la ISO 3382
    indice_cruce = np.where(schroeder <= umbral)[0]
    print("Indice de cruce =", indice_cruce)
    if indice_cruce.size > 0:
        # Toma el primer índice de cruce
        indice_cruce = indice_cruce[0]

        # Convierte el índice a tiempo en segundos
        tiempo_cruce = indice_cruce / fs

        print("Tiempo de cruce =", tiempo_cruce)

        # El EDT es seis veces el tiempo en que la integral cruza -10 dB
        edt = 6 * tiempo_cruce
    
    else:
        # No se encontró ningún índice que cumpla con el umbral
        edt = 0  # O cualquier otro valor que desees asignar

    return edt
# Ejemplo de uso:
# Supongamos que tienes la función de Schroeder suavizada y la frecuencia de muestreo
schroeder = integral_schroeder  # Reemplaza con tu función de Schroeder
fs = 44100  # Reemplaza con tu frecuencia de muestreo
# Calculate the EDT
edt = calcular_edt(integral_schroeder, fs)
# Imprime el resultado
print("EDT:", edt, "segundos")

def calcular_t10(schroeder, fs):
    """
    Calcula el tiempo de reverberación T10 desde una función de Schroeder suavizada.

    Parámetros:
    - schroeder: np.array, función de Schroeder suavizada.
    - fs: int, frecuencia de muestreo en Hz.

    Retorna:
    - t10: float, tiempo de reverberación T10 en segundos.
    """
    # Encuentra el tiempo en el que la integral cruza -5 dB
    umbral_A= -5  # Puedes ajustar este valor según las especificaciones de la ISO 3382
    umbral_B = -15
    indice_cruce_5 = np.where(schroeder <= umbral_A)[0]
    indice_cruce_15 = np.where(schroeder <= umbral_B)[0]

    # Toma el primer índice de cruce
    indice_cruce_5 = indice_cruce_5[0]
    indice_cruce_15 = indice_cruce_15[0]
    
    # Convierte el índice a tiempo en segundos
    tiempo_cruce_5 = indice_cruce_5 / fs
    tiempo_cruce_15 = indice_cruce_15 / fs
    # La diferencia entre los dos cruces determina el tiempo de reverberación T10
    t10 = tiempo_cruce_15 - tiempo_cruce_5
    return t10

# Supongamos que tienes la función de Schroeder suavizada y la frecuencia de muestreo
schroeder = integral_schroeder  # Reemplaza con tu función de Schroeder
fs = 44100  # Reemplaza con tu frecuencia de muestreo
# Calculate the EDT
t10 = calcular_t10(integral_schroeder, fs)
# Imprime el resultado
print("T10:", t10, "segundos")

def calcular_t20(schroeder, fs):
    """
    Calcula el tiempo de reverberación T20 desde una función de Schroeder suavizada.

    Parámetros:
    - schroeder: np.array, función de Schroeder suavizada.
    - fs: int, frecuencia de muestreo en Hz.

    Retorna:
    - t10: float, tiempo de reverberación T10 en segundos.
    """
    # Encuentra el tiempo en el que la integral cruza -5 dB
    umbral_A= -5  # Puedes ajustar este valor según las especificaciones de la ISO 3382
    umbral_B = -25
    indice_cruce_5 = np.where(schroeder <= umbral_A)[0]
    indice_cruce_25 = np.where(schroeder <= umbral_B)[0]

    # Toma el primer índice de cruce
    indice_cruce_5 = indice_cruce_5[0]
    indice_cruce_25 = indice_cruce_25[0]
    
    # Convierte el índice a tiempo en segundos
    tiempo_cruce_5 = indice_cruce_5 / fs
    tiempo_cruce_25 = indice_cruce_25 / fs
    # La diferencia entre los dos cruces determina el tiempo de reverberación T10
    t20 = tiempo_cruce_25 - tiempo_cruce_5
    return t20

# Supongamos que tienes la función de Schroeder suavizada y la frecuencia de muestreo
schroeder = integral_schroeder  # Reemplaza con tu función de Schroeder
fs = 44100  # Reemplaza con tu frecuencia de muestreo
# Calculate the EDT
t20 = calcular_t20(integral_schroeder, fs)
# Imprime el resultado
print("T20:", t20, "segundos")

def calcular_t30(schroeder, fs):
    """
    Calcula el tiempo de reverberación T30 desde una función de Schroeder suavizada.

    Parámetros:
    - schroeder: np.array, función de Schroeder suavizada.
    - fs: int, frecuencia de muestreo en Hz.

    Retorna:
    - t30: float, tiempo de reverberación T30 en segundos.
    """
    # Encuentra el tiempo en el que la integral cruza -5 dB
    umbral_A= -5  # Puedes ajustar este valor según las especificaciones de la ISO 3382
    umbral_B = -35
    indice_cruce_5 = np.where(schroeder <= umbral_A)[0]
    indice_cruce_35 = np.where(schroeder <= umbral_B)[0]

    # Toma el primer índice de cruce
    indice_cruce_5 = indice_cruce_5[0]
    indice_cruce_35 = indice_cruce_35[0]
    
    # Convierte el índice a tiempo en segundos
    tiempo_cruce_5 = indice_cruce_5 / fs
    tiempo_cruce_35 = indice_cruce_35 / fs
    # La diferencia entre los dos cruces determina el tiempo de reverberación T10
    t30 = tiempo_cruce_35 - tiempo_cruce_5
    return t30

# Supongamos que tienes la función de Schroeder suavizada y la frecuencia de muestreo
schroeder = integral_schroeder  # Reemplaza con tu función de Schroeder
fs = 44100  # Reemplaza con tu frecuencia de muestreo
# Calcular T30
t30 = calcular_t30(integral_schroeder, fs)
# Imprime el resultado
print("T30:", t30, "segundos")

# D50
t_50 = int(0.05 * fs)  
D50 = np.sum(np.power(integral_schroeder,2)[0:t_50]) / np.sum(np.power(integral_schroeder,2))
print("D50", D50,"%")

t_80 = int(0.08 * fs)
C80 = 10* (np.log10(np.sum(np.power(integral_schroeder,2)[0:t_80]) / np.sum(np.power(integral_schroeder,2)[t_80:])))
print("C80:", C80, "dB")




