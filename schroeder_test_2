import numpy as np
import matplotlib.pyplot as plt
import soundfile as sf
from pre_procesamiento import plot_dominio_temporal

def calculate_schroeder_integral(hA):
    """
    Calcula la integral de Schroeder para una respuesta al impulso dada.
    Parameters:
    - hA: np.array, respuesta al impulso suavizada.
    Returns:
    - E: np.array, valores de la integral de Schroeder.
    """
    # Crear el arreglo de tiempo
    tau = np.arange(0, len(hA))
    # Definir td y calcular la integral de Schroeder
    td = 100000  # Puedes ajustar este valor según tus necesidades
    E = np.sum(hA[:]**2) - np.cumsum(hA[:]**2)
    E = 10 * np.log10(E / np.sum(hA**2))
    return E

# Calcular la integral de Schroeder
hA, tasa_muestreo = sf.read("1st_baptist_nashville_balcony_mono copy.wav")
integral_schroeder = calculate_schroeder_integral(hA)
sf.write("Audio_Schroeder.wav", integral_schroeder, 44100)
# Imprimir el resultado
print(integral_schroeder)
# Crear el arreglo de tiempo
tau = np.arange(0, len(hA))
# Graficar la señal original y la integral de Schroeder
plt.subplot(2, 1, 1)
plt.plot(tau, hA, label='Respuesta al Impulso Suavizada')
plt.title('Señal Original')
plt.xlabel('Tiempo')
plt.ylabel('Amplitud')
plt.legend()
plt.subplot(2, 1, 2)
plt.plot(tau, integral_schroeder, label='Integral de Schroeder')
plt.title('Integral de Schroeder')
plt.xlabel('Tiempo')
plt.ylabel('Amplitud (dB)')
plt.legend()
plt.tight_layout()
plt.show()

def convertir_audio_a_escala_logaritmica(señal_audio):
    """
    Convierte un archivo de audio en escala logarítmica y devuelve el resultado como un array.

    Parámetros:
    señal_audio (np.array): Array de la señal de audio.

    Retorna:
    numpy.ndarray: El array de la señal en escala logarítmica.
    """
    # Normalizar los valores de audio entre -1 y 1
    audio_data = señal_audio.astype(np.float32) / np.max(np.abs(señal_audio))

    # Aplicar la conversión logarítmica
    audio_log = 20 * np.log10(np.abs(audio_data))

    return audio_log

def plot_dominio_temporal2(señal1, señal2, fs=44100, inicio=None, duracion=None, umbral_amplitud=None):
    """
    Muestra el dominio temporal de la señal con un umbral de amplitud.

    Parámetros
    ----------
    señal : np.array
        Array que representa la señal de audio.
    fs : int
        Frecuencia de muestreo en Hz de la señal.
    inicio : float, opcional
        Tiempo de inicio para la ventana en segundos.
    duracion : float, opcional
        Duración de la ventana en segundos.
    umbral_amplitud : float, opcional
        Umbral de amplitud para mostrar valores en el gráfico.

    Retorna
    -------
    None
    """
    # Calcula los valores de tiempo
    tiempo = np.arange(len(señal1)) / fs
    tiempo2 = np.arange(len(señal2)) / fs

    # Establece el índice de inicio y final
    if inicio is None:
        inicio = 0
    if duracion is None:
        duracion = tiempo[-1]

    # Encuentra los índices correspondientes al inicio y final de la ventana
    inicio_idx = int(inicio * fs)
    fin_idx = int((inicio + duracion) * fs)

    # Asegura que los índices estén dentro de los límites de la señal
    inicio_idx = max(0, inicio_idx)
    fin_idx = min(len(señal1), fin_idx)
    fin_idx2 = min(len(señal2), fin_idx)

    # Aplicar umbral de amplitud si se proporciona
    if umbral_amplitud is not None:
        señal1[señal1 < umbral_amplitud] = umbral_amplitud

    # Crea una nueva figura y plotea la señal en la ventana especificada
    plt.figure(figsize=(10, 4))
    plt.plot(tiempo[inicio_idx:fin_idx], señal1[inicio_idx:fin_idx])
    plt.plot(tiempo[inicio_idx:fin_idx2], señal2[inicio_idx:fin_idx2])
    plt.title('Dominio Temporal de la Señal')
    plt.xlabel('Tiempo (segundos)')
    plt.ylabel('Amplitud')
    plt.grid(True)
    plt.show()

# Normaliza la señal
normalized_audio = convertir_audio_a_escala_logaritmica(hA)
plot_dominio_temporal2(normalized_audio, integral_schroeder, fs=44100)
