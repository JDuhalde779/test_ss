import numpy as np
import matplotlib.pyplot as plt
import soundfile as sf
from pre_procesamiento import plot_dominio_temporal

def calculate_schroeder_integral(hA):
    """
    Calcula la integral de Schroeder para una respuesta al impulso dada.
    Parameters:
    - hA: np.array, respuesta al impulso suavizada.
    Returns:
    - E: np.array, valores de la integral de Schroeder.
    """
    # Verificar que no haya valores nan o inf en la respuesta al impulso
    if np.isnan(hA).any() or np.isinf(hA).any():
        raise ValueError("La respuesta al impulso contiene valores no numéricos.")
    # Crear el arreglo de tiempo
    tau = np.arange(0, len(hA))
    # Calcular la integral de Schroeder
    E = np.sum(hA[:]**2) - np.cumsum(hA[:]**2)
    E = 10 * np.log10(E / np.sum(hA**2))
    return E

# Calcular la integral de Schroeder
hA, tasa_muestreo = sf.read("1st_baptist_nashville_balcony_mono copy.wav")
integral_schroeder = calculate_schroeder_integral(hA)
sf.write("Audio_Schroeder.wav", integral_schroeder, 44100)
# Imprimir el resultado
print(integral_schroeder)
# Crear el arreglo de tiempo
tau = np.arange(0, len(hA))
# Graficar la señal original y la integral de Schroeder
plt.subplot(2, 1, 1)
plt.plot(tau, hA, label='Respuesta al Impulso Suavizada')
plt.title('Señal Original')
plt.xlabel('Tiempo')
plt.ylabel('Amplitud')
plt.legend()
plt.subplot(2, 1, 2)
plt.plot(tau, integral_schroeder, label='Integral de Schroeder')
plt.title('Integral de Schroeder')
plt.xlabel('Tiempo')
plt.ylabel('Amplitud (dB)')
plt.legend()
plt.tight_layout()
plt.show()

def convertir_audio_a_escala_logaritmica(señal_audio):
    """
    Convierte un archivo de audio en escala logarítmica y devuelve el resultado como un array.

    Parámetros:
    señal_audio (np.array): Array de la señal de audio.

    Retorna:
    numpy.ndarray: El array de la señal en escala logarítmica.
    """
    # Normalizar los valores de audio entre -1 y 1
    audio_data = señal_audio.astype(np.float32) / np.max(np.abs(señal_audio))

    # Aplicar la conversión logarítmica
    audio_log = 20 * np.log10(np.abs(audio_data))

    return audio_log

def plot_dominio_temporal2(señal1, señal2, fs=44100, inicio=None, duracion=None, umbral_amplitud=None):
    """
    Muestra el dominio temporal de la señal con un umbral de amplitud.

    Parámetros
    ----------
    señal : np.array
        Array que representa la señal de audio.
    fs : int
        Frecuencia de muestreo en Hz de la señal.
    inicio : float, opcional
        Tiempo de inicio para la ventana en segundos.
    duracion : float, opcional
        Duración de la ventana en segundos.
    umbral_amplitud : float, opcional
        Umbral de amplitud para mostrar valores en el gráfico.

    Retorna
    -------
    None
    """
    # Calcula los valores de tiempo
    tiempo = np.arange(len(señal1)) / fs
    tiempo2 = np.arange(len(señal2)) / fs

    # Establece el índice de inicio y final
    if inicio is None:
        inicio = 0
    if duracion is None:
        duracion = tiempo[-1]

    # Encuentra los índices correspondientes al inicio y final de la ventana
    inicio_idx = int(inicio * fs)
    fin_idx = int((inicio + duracion) * fs)

    # Asegura que los índices estén dentro de los límites de la señal
    inicio_idx = max(0, inicio_idx)
    fin_idx = min(len(señal1), fin_idx)
    fin_idx2 = min(len(señal2), fin_idx)

    # Aplicar umbral de amplitud si se proporciona
    if umbral_amplitud is not None:
        señal1[señal1 < umbral_amplitud] = umbral_amplitud

    # Crea una nueva figura y plotea la señal en la ventana especificada
    plt.figure(figsize=(10, 4))
    plt.plot(tiempo[inicio_idx:fin_idx], señal1[inicio_idx:fin_idx])
    plt.plot(tiempo[inicio_idx:fin_idx2], señal2[inicio_idx:fin_idx2])
    plt.title('Dominio Temporal de la Señal')
    plt.xlabel('Tiempo (segundos)')
    plt.ylabel('Amplitud')
    plt.grid(True)
    plt.show()

# Normaliza la señal
normalized_audio = convertir_audio_a_escala_logaritmica(hA)
plot_dominio_temporal2(normalized_audio, integral_schroeder, fs=44100)



def calculate_edt(schroeder_function, fs):
    """
    Calcula el tiempo de reverberación EDT desde una función de Schroeder suavizada.

    Parámetros:
    - schroeder_function: np.array, función de Schroeder suavizada.
    - fs: int, frecuencia de muestreo en Hz.

    Retorna:
    - edt: float, tiempo de reverberación EDT en segundos.
    """
    # Calcula la integral de Schroeder
    schroeder_integral = np.cumsum(schroeder_function[::-1]**2)[::-1]

    # Encuentra el tiempo en el que la integral cruza -10 dB
    threshold = -10  # Puedes ajustar este valor según las especificaciones de la ISO 3382
    idx_crossing = np.where(schroeder_integral <= threshold)[0][0]
    if len(idx_crossing) > 0:
        # Convierte el índice a tiempo en segundos
        time_crossing = idx_crossing[0] / fs

        # El EDT es seis veces el tiempo en que la integral cruza -10 dB
        edt = 6 * time_crossing
    else:
        # No se encontró ningún índice que cumpla con el umbral
        edt = 0  # O cualquier otro valor que desees asignar

    return edt
# Ejemplo de uso:
# Supongamos que tienes la función de Schroeder suavizada y la frecuencia de muestreo
schroeder_function = integral_schroeder  # Reemplaza con tu función de Schroeder
fs = 44100  # Reemplaza con tu frecuencia de muestreo
# Calculate the EDT
edt = calculate_edt(integral_schroeder, fs)
# Imprime el resultado
print("EDT:", edt, "segundos")


def calculate_t20(schroeder_function, fs):
    """
    Calcula el tiempo de reverberación T20 desde una función de Schroeder suavizada.

    Parámetros:
    - schroeder_function: np.array, función de Schroeder suavizada.
    - fs: int, frecuencia de muestreo en Hz.

    Retorna:
    - t20: float, tiempo de reverberación T20 en segundos.
    """
    # Calcula la integral de Schroeder
    schroeder_integral = np.cumsum(schroeder_function[::-1]**2)[::-1]

    # Encuentra el tiempo en el que la integral cruza -5 dB
    threshold = -5  # Puedes ajustar este valor según las especificaciones de la ISO 3382
    idx_crossing = np.where(schroeder_integral <= threshold)[0][0]

    # Convierte el índice a tiempo en segundos
    time_crossing = idx_crossing / fs

    # El T20 es tres veces el tiempo en que la integral cruza -5 dB
    t20 = 3 * time_crossing

    return t20
# Ejemplo de uso:
# Supongamos que tienes la función de Schroeder suavizada y la frecuencia de muestreo
schroeder_function = ...  # Reemplaza con tu función de Schroeder
fs = ...  # Reemplaza con tu frecuencia de muestreo
# Calculate the T20
t20 = calculate_t20(integral_schroeder, fs)
# Imprime el resultado
print("T20:", t20, "segundos")

def calculate_t30(schroeder_function, fs):
    """
    Calcula el tiempo de reverberación T30 desde una función de Schroeder suavizada.

    Parámetros:
    - schroeder_function: np.array, función de Schroeder suavizada.
    - fs: int, frecuencia de muestreo en Hz.

    Retorna:
    - t30: float, tiempo de reverberación T30 en segundos.
    """
    # Calcula la integral de Schroeder
    schroeder_integral = np.cumsum(schroeder_function[::-1]**2)[::-1]

    # Encuentra el tiempo en el que la integral cruza 0 dB
    threshold = 0  # Puedes ajustar este valor según las especificaciones de la ISO 3382
    idx_crossing = np.where(schroeder_integral <= threshold)[0][0]

    # Convierte el índice a tiempo en segundos
    time_crossing = idx_crossing / fs

    # El T30 es seis veces el tiempo en que la integral cruza 0 dB
    t30 = 6 * time_crossing

    return t30
# Ejemplo de uso:
# Supongamos que tienes la función de Schroeder suavizada y la frecuencia de muestreo
schroeder_function = ...  # Reemplaza con tu función de Schroeder
fs = ...  # Reemplaza con tu frecuencia de muestreo
# Calculate the T30
t30 = calculate_t30(integral_schroeder, fs)
# Imprime el resultado
print("T30:", t30, "segundos")

def calculate_t60(schroeder_function, fs):
    """
    Calcula el tiempo de reverberación T60 desde una función de Schroeder suavizada.

    Parámetros:
    - schroeder_function: np.array, función de Schroeder suavizada.
    - fs: int, frecuencia de muestreo en Hz.

    Retorna:
    - t60: float, tiempo de reverberación T60 en segundos.
    """
    # Calcula la integral de Schroeder
    schroeder_integral = np.cumsum(schroeder_function[::-1]**2)[::-1]

    # Encuentra el tiempo en el que la integral cruza 0 dB
    threshold = 0  # Puedes ajustar este valor según las especificaciones de la ISO 3382
    idx_crossing = np.where(schroeder_integral <= threshold)[0][0]

    # Convierte el índice a tiempo en segundos
    time_crossing = idx_crossing / fs

    # El T60 es nueve veces el tiempo en que la integral cruza 0 dB
    t60 = 9 * time_crossing

    return t60
# Ejemplo de uso:
# Supongamos que tienes la función de Schroeder suavizada y la frecuencia de muestreo
schroeder_function = ...  # Reemplaza con tu función de Schroeder
fs = ...  # Reemplaza con tu frecuencia de muestreo
# Calculate the T60
t60 = calculate_t60(integral_schroeder, fs)
# Imprime el resultado
print("T60:", t60, "segundos")

def calculate_c80(schroeder_function, fs):
    """
    Calcula el C80 desde una función de Schroeder suavizada.

    Parámetros:
    - schroeder_function: np.array, función de Schroeder suavizada.
    - fs: int, frecuencia de muestreo en Hz.

    Retorna:
    - c80: float, C80 en dB.
    """
    # Calcula la integral de Schroeder
    schroeder_integral = np.cumsum(schroeder_function[::-1]**2)[::-1]

    # Encuentra el tiempo en el que la integral cruza 0 dB
    threshold = 0  # Puedes ajustar este valor según las especificaciones de la ISO 3382
    idx_crossing = np.where(schroeder_integral <= threshold)[0][0]

    # Calcula la integral de Schroeder entre 0 y 80 ms
    idx_80ms = int(0.08 * fs)
    schroeder_integral_80ms = np.cumsum(schroeder_function[idx_crossing:idx_crossing + idx_80ms]**2)

    # Calcula el C80
    c80 = 10 * np.log10(schroeder_integral[idx_crossing] / schroeder_integral_80ms[-1])

    return c80
# Ejemplo de uso:
# Supongamos que tienes la función de Schroeder suavizada y la frecuencia de muestreo
schroeder_function = ...  # Reemplaza con tu función de Schroeder
fs = ...  # Reemplaza con tu frecuencia de muestreo
# Calculate the C80
c80 = calculate_c80(integral_schroeder, fs)
# Imprime el resultado
print("C80:", c80, "dB")

def calculate_d50(schroeder_function, fs):
    """
    Calcula el D50 desde una función de Schroeder suavizada.

    Parámetros:
    - schroeder_function: np.array, función de Schroeder suavizada.
    - fs: int, frecuencia de muestreo en Hz.

    Retorna:
    - d50: float, D50 en porcentaje.
    """
    # Calcula la integral de Schroeder
    schroeder_integral = np.cumsum(schroeder_function[::-1]**2)[::-1]

    # Encuentra el tiempo en el que la integral cruza 0 dB
    threshold = 0  # Puedes ajustar este valor según las especificaciones de la ISO 3382
    idx_crossing = np.where(schroeder_integral <= threshold)[0][0]

    # Calcula la integral de Schroeder entre 0 y 50 ms
    idx_50ms = int(0.05 * fs)
    schroeder_integral_50ms = np.cumsum(schroeder_function[idx_crossing:idx_crossing + idx_50ms]**2)

    # Calcula el D50
    d50 = 100 * schroeder_integral_50ms[-1] / schroeder_integral[idx_crossing]

    return d50
# Ejemplo de uso:
# Supongamos que tienes la función de Schroeder suavizada y la frecuencia de muestreo
schroeder_function = ...  # Reemplaza con tu función de Schroeder
fs = ...  # Reemplaza con tu frecuencia de muestreo
# Calculate the D50
d50 = calculate_d50(integral_schroeder, fs)
# Imprime el resultado
print("D50:", d50, "%")


